---
tags:
  - Математика/ML
up: "[[Анализ Данных]]"
---

**Ранжирование** (англ. _learning to rank_) — это класс задач [машинного обучения с учителем](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9E%D0%B1%D1%89%D0%B8%D0%B5_%D0%BF%D0%BE%D0%BD%D1%8F%D1%82%D0%B8%D1%8F "Общие понятия"), заключающихся в автоматическом подборе ранжирующей модели по обучающей выборке, состоящей из множества списков и заданных частичных порядков на элементах внутри каждого списка. Частичный порядок обычно задаётся путём указания оценки для каждого элемента (например, «релевантен» или «не релевантен»). Цель ранжирующей модели — наилучшим образом приблизить и обобщить способ ранжирования в обучающей выборке на новые данные.

## Постановка задачи

$X$ — множество объектов.

$X^{l}=\{x_{1},\dots,x_{l}\}$— обучающая выборка.

$i\lt j$ — правильный [частичный порядок](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9E%D1%82%D0%BD%D0%BE%D1%88%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%BE%D1%80%D1%8F%D0%B4%D0%BA%D0%B0 "Отношение порядка") на парах $(i,j) \in \{1,\dots,l\}$. "Правильность" зависит от постановки задачи, а именно запись$i\lt j$ может означать, что объект ii имеет ранг выше, чем объект $j$, так и наоборот.

**Задача:**

Построить ранжирующую функцию $a:X \rightarrow \mathbb{R}$  такую, что: $i \lt j \Rightarrow a(x_{i}) \lt a(x_{j})$ .

**Линейная модель ранжирования:**

$$a(x;\omega)=<x,\omega> \text{ где }x \rightarrow(f_{1}(x),\dots,f_{n}(x)) \in \mathbb{R}^{n} \text{ - Вектор признаков объекта }x$$
## Формальное определение ранга (Для чисел)

Пусть у нас есть последовательность из $N$ чисел $x_{1},x_{2},\dots,x_{N}$. Тогда **ранг** элемента $x_{i}$— это позиция $x_{i}$​ в отсортированной версии последовательности. Если значения уникальны, ранги всегда будут целыми числами от $1$ до $N$.

```c++
vector<int> calculateRanks(const vector<int>& values) {
	int n = values.size();
	vector<pair<int, int>> valueIndex(n);
	for (int i = 0; i < n; ++i) {
		valueIndex[i] = {values[i], i};
	} 
	sort(valueIndex.begin(), valueIndex.end());
	vector<int> ranks(n);
	for (int i = 0; i < n; ++i) { 
		ranks[valueIndex[i].second] = i + 1; 
	} 
	return ranks; 
}
```

### **Особые случаи**

1. **Повторяющиеся значения (связанное ранжирование)**: Если значения повторяются, то обычно используют **средний ранг**. Например:
	- Последовательность: $[30,10,20,20,40]$
	- Сортировка: $[10,20,20,30,40]$,
	- Ранги: $1,2.5,2.5,4,5$ (у одинаковых значений $20$ средний ранг $\dfrac{2+3}{2}=2.5$.
1. **Ранжирование по убыванию**: Ранги присваиваются в обратном порядке:
	- Для последовательности $[30,10,20,40]$
	- Ранги по убыванию: $[2,4,3,1]$.