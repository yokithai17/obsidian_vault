---
tags:
  - Программирование/Структуры
up: "[[Структура данных]]"
---

### Итераторы

`bimap` предоставляет возможность итерироваться по левым или правым ключам в порядках, определённых их компараторами. Для этого он реализует две пары методов для получения итераторов: `begin_left()`+`end_left()` и `begin_right()`+`end_right()`.

Итераторы повторяют соответствующее поведение `std::map`, и вдобавок реализуют метод `flip`, возвращающий парный итератор (на противоположный элемент в паре) — превращает `left_iterator` в `right_iterator` и наоборот.

### Семантика операций
#### insert

Вставляет пару `(left, right)`, возвращает итератор на `left`. Если такой `left` или такой `right` уже присутствуют в `bimap`, вставка не производится и возвращается `end_left()`.

#### erase_left, erase_right от итератора

Пусть переданный итератор ссылается на некоторый ключ `e`. Тогда `erase_left` (`erase_right`) удаляет `e` и противоположный ему ключ и инвалидирует все итераторы, ссылающиеся на них. Возвращает итератор на пару после удалённой.

#### erase_left, erase_right от ключа

Аналогично перегрузке от итератора, но по ключу: удаляет его, если он присутствует, иначе не делает ничего. Возвращает `true`, если пара была удалена.

#### erase_left, erase_right от пары итераторов

Аналогично перегрузке от итератора, но удаляет все ключи в диапазоне `[first, last)`. Возвращает итератор на пару после последней из удалённых.

#### find_left, find_right

Возвращает итератор по ключу. Если не найден — соответствующий `end()`.

#### at_left, at_right

Возвращает противоположный ключ по ключу. Если не найден — бросает `std::out_of_range`.

#### at_left_or_default, at_right_or_default

Возвращает противоположный ключ по ключу. Если не найден — добавляет его в `bimap`, а на противоположную сторону кладёт значение, полученное вызовом конструктора по умолчанию, и возвращает ссылку на него. При этом, если дефолтный противоположный ключ уже существует — должен поменять соответствующий ему ключ на запрашиваемый (см. тесты).

#### lower_bound_left, lower_bound_right, upper_bound_left, upper_bound_right

Поведение аналогично [std::lower_bound](https://en.cppreference.com/w/cpp/algorithm/lower_bound) и [std::upper_bound](https://en.cppreference.com/w/cpp/algorithm/upper_bound).
