
## Как их хранить?

Какие типы можно хранить как координаты?
```c++
using long long C
using long double R
```

Затем определим комплексного числа P, представляющий точку или вектор

```c++
using P = std::complex<C>;
```

Наконец определим макросы для ссылки на координаты x, y:

```c++
#define X real()
#define Y img()
```

Например в следюущем фрагменте создается точка $p=(4,2)$ и печатается координаты:
```c++
P p = {4, 2};
std::cout << p.X << ' ' << p.Y << '\n'; // 4 2
```

А ниже создается вектор $v=(3,1) \ u=(2,2)$ после чего вычисляется их сумма  $s=u+v$:

```c++
P v = {3,1};
P u = {2,2};
P s = v + u;
std::cout << s.X << ' ' << s.Y << '\n'; // 5 3
```

## Функции

В классе `complex` имеются также функции, полезные для решения задач.
К примеру `abs(v)` вычисляет длину $|v|$ вектора $v=(x,y)$ по формуле $\sqrt{x^{2}+y^{2}}$. Ее можно также использовать для вычисления расстояния между точками $(x_{1}, y_{2})$, $(x_{1}, y_{2})$ поскольку это расстояние равно длине вектора $(x_{1}-x_{2},y_{1}-y_{2})$.

В следующем коде вычисляется расстояние между точками $(4,2)$ и $(3,-1)$

```c++
P a = {4, 2};
P b = {3, -1};
std::cout << std::abs(b - a);
```

Функция `arg(v)` вычисляет полярный угол между векторами $v=(x,y)$ и положительным направлением оси $x$.

Функция `polar(s,a)` конструирует вектор длины $s$  и полярным углом $a$. Для поворота вектора на угол $a$ нужно умножить на вектор длины $1$ с полярным углом $a$.

```c++
P v = {4,2};
std::cout << arg(v) << '\n' //0.46..
v *= polar(1.0, 0.5);
std::cout << argv(v) << '\n'; //0.96..
```

### Векторное произведение

по определение векторное произведение двух вектором $a=(x_{1}, y_{2}), \ b=(x_{2}, y_{2})$ вычисляется как $x_{1}y_{2} - x_{2}y_{1}$. оно дает направление вектора $b$ относительно вектора $a$.

```
#define vecProduct(a, b) (conj(a)*b).Y
```

